{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Preprocessor = void 0;\nconst unicode_js_1 = require(\"../common/unicode.js\");\nconst error_codes_js_1 = require(\"../common/error-codes.js\");\n//Const\nconst DEFAULT_BUFFER_WATERLINE = 1 << 16;\n//Preprocessor\n//NOTE: HTML input preprocessing\n//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)\nclass Preprocessor {\n  constructor(handler) {\n    this.handler = handler;\n    this.html = '';\n    this.pos = -1;\n    // NOTE: Initial `lastGapPos` is -2, to ensure `col` on initialisation is 0\n    this.lastGapPos = -2;\n    this.gapStack = [];\n    this.skipNextNewLine = false;\n    this.lastChunkWritten = false;\n    this.endOfChunkHit = false;\n    this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;\n    this.isEol = false;\n    this.lineStartPos = 0;\n    this.droppedBufferSize = 0;\n    this.line = 1;\n    //NOTE: avoid reporting errors twice on advance/retreat\n    this.lastErrOffset = -1;\n  }\n  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */\n  get col() {\n    return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);\n  }\n  get offset() {\n    return this.droppedBufferSize + this.pos;\n  }\n  getError(code) {\n    const {\n      line,\n      col,\n      offset\n    } = this;\n    return {\n      code,\n      startLine: line,\n      endLine: line,\n      startCol: col,\n      endCol: col,\n      startOffset: offset,\n      endOffset: offset\n    };\n  }\n  _err(code) {\n    if (this.handler.onParseError && this.lastErrOffset !== this.offset) {\n      this.lastErrOffset = this.offset;\n      this.handler.onParseError(this.getError(code));\n    }\n  }\n  _addGap() {\n    this.gapStack.push(this.lastGapPos);\n    this.lastGapPos = this.pos;\n  }\n  _processSurrogate(cp) {\n    //NOTE: try to peek a surrogate pair\n    if (this.pos !== this.html.length - 1) {\n      const nextCp = this.html.charCodeAt(this.pos + 1);\n      if ((0, unicode_js_1.isSurrogatePair)(nextCp)) {\n        //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.\n        this.pos++;\n        //NOTE: add a gap that should be avoided during retreat\n        this._addGap();\n        return (0, unicode_js_1.getSurrogatePairCodePoint)(cp, nextCp);\n      }\n    }\n    //NOTE: we are at the end of a chunk, therefore we can't infer the surrogate pair yet.\n    else if (!this.lastChunkWritten) {\n      this.endOfChunkHit = true;\n      return unicode_js_1.CODE_POINTS.EOF;\n    }\n    //NOTE: isolated surrogate\n    this._err(error_codes_js_1.ERR.surrogateInInputStream);\n    return cp;\n  }\n  willDropParsedChunk() {\n    return this.pos > this.bufferWaterline;\n  }\n  dropParsedChunk() {\n    if (this.willDropParsedChunk()) {\n      this.html = this.html.substring(this.pos);\n      this.lineStartPos -= this.pos;\n      this.droppedBufferSize += this.pos;\n      this.pos = 0;\n      this.lastGapPos = -2;\n      this.gapStack.length = 0;\n    }\n  }\n  write(chunk, isLastChunk) {\n    if (this.html.length > 0) {\n      this.html += chunk;\n    } else {\n      this.html = chunk;\n    }\n    this.endOfChunkHit = false;\n    this.lastChunkWritten = isLastChunk;\n  }\n  insertHtmlAtCurrentPos(chunk) {\n    this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);\n    this.endOfChunkHit = false;\n  }\n  startsWith(pattern, caseSensitive) {\n    // Check if our buffer has enough characters\n    if (this.pos + pattern.length > this.html.length) {\n      this.endOfChunkHit = !this.lastChunkWritten;\n      return false;\n    }\n    if (caseSensitive) {\n      return this.html.startsWith(pattern, this.pos);\n    }\n    for (let i = 0; i < pattern.length; i++) {\n      const cp = this.html.charCodeAt(this.pos + i) | 0x20;\n      if (cp !== pattern.charCodeAt(i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  peek(offset) {\n    const pos = this.pos + offset;\n    if (pos >= this.html.length) {\n      this.endOfChunkHit = !this.lastChunkWritten;\n      return unicode_js_1.CODE_POINTS.EOF;\n    }\n    const code = this.html.charCodeAt(pos);\n    return code === unicode_js_1.CODE_POINTS.CARRIAGE_RETURN ? unicode_js_1.CODE_POINTS.LINE_FEED : code;\n  }\n  advance() {\n    this.pos++;\n    //NOTE: LF should be in the last column of the line\n    if (this.isEol) {\n      this.isEol = false;\n      this.line++;\n      this.lineStartPos = this.pos;\n    }\n    if (this.pos >= this.html.length) {\n      this.endOfChunkHit = !this.lastChunkWritten;\n      return unicode_js_1.CODE_POINTS.EOF;\n    }\n    let cp = this.html.charCodeAt(this.pos);\n    //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters\n    if (cp === unicode_js_1.CODE_POINTS.CARRIAGE_RETURN) {\n      this.isEol = true;\n      this.skipNextNewLine = true;\n      return unicode_js_1.CODE_POINTS.LINE_FEED;\n    }\n    //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character\n    //must be ignored.\n    if (cp === unicode_js_1.CODE_POINTS.LINE_FEED) {\n      this.isEol = true;\n      if (this.skipNextNewLine) {\n        // `line` will be bumped again in the recursive call.\n        this.line--;\n        this.skipNextNewLine = false;\n        this._addGap();\n        return this.advance();\n      }\n    }\n    this.skipNextNewLine = false;\n    if ((0, unicode_js_1.isSurrogate)(cp)) {\n      cp = this._processSurrogate(cp);\n    }\n    //OPTIMIZATION: first check if code point is in the common allowed\n    //range (ASCII alphanumeric, whitespaces, big chunk of BMP)\n    //before going into detailed performance cost validation.\n    const isCommonValidRange = this.handler.onParseError === null || cp > 0x1f && cp < 0x7f || cp === unicode_js_1.CODE_POINTS.LINE_FEED || cp === unicode_js_1.CODE_POINTS.CARRIAGE_RETURN || cp > 0x9f && cp < 64976;\n    if (!isCommonValidRange) {\n      this._checkForProblematicCharacters(cp);\n    }\n    return cp;\n  }\n  _checkForProblematicCharacters(cp) {\n    if ((0, unicode_js_1.isControlCodePoint)(cp)) {\n      this._err(error_codes_js_1.ERR.controlCharacterInInputStream);\n    } else if ((0, unicode_js_1.isUndefinedCodePoint)(cp)) {\n      this._err(error_codes_js_1.ERR.noncharacterInInputStream);\n    }\n  }\n  retreat(count) {\n    this.pos -= count;\n    while (this.pos < this.lastGapPos) {\n      this.lastGapPos = this.gapStack.pop();\n      this.pos--;\n    }\n    this.isEol = false;\n  }\n}\nexports.Preprocessor = Preprocessor;","map":{"version":3,"names":["Object","defineProperty","exports","value","Preprocessor","unicode_js_1","require","error_codes_js_1","DEFAULT_BUFFER_WATERLINE","constructor","handler","html","pos","lastGapPos","gapStack","skipNextNewLine","lastChunkWritten","endOfChunkHit","bufferWaterline","isEol","lineStartPos","droppedBufferSize","line","lastErrOffset","col","Number","offset","getError","code","startLine","endLine","startCol","endCol","startOffset","endOffset","_err","onParseError","_addGap","push","_processSurrogate","cp","length","nextCp","charCodeAt","isSurrogatePair","getSurrogatePairCodePoint","CODE_POINTS","EOF","ERR","surrogateInInputStream","willDropParsedChunk","dropParsedChunk","substring","write","chunk","isLastChunk","insertHtmlAtCurrentPos","startsWith","pattern","caseSensitive","i","peek","CARRIAGE_RETURN","LINE_FEED","advance","isSurrogate","isCommonValidRange","_checkForProblematicCharacters","isControlCodePoint","controlCharacterInInputStream","isUndefinedCodePoint","noncharacterInInputStream","retreat","count","pop"],"sources":["C:/Users/vedic/node_modules/parse5/dist/cjs/tokenizer/preprocessor.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Preprocessor = void 0;\nconst unicode_js_1 = require(\"../common/unicode.js\");\nconst error_codes_js_1 = require(\"../common/error-codes.js\");\n//Const\nconst DEFAULT_BUFFER_WATERLINE = 1 << 16;\n//Preprocessor\n//NOTE: HTML input preprocessing\n//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)\nclass Preprocessor {\n    constructor(handler) {\n        this.handler = handler;\n        this.html = '';\n        this.pos = -1;\n        // NOTE: Initial `lastGapPos` is -2, to ensure `col` on initialisation is 0\n        this.lastGapPos = -2;\n        this.gapStack = [];\n        this.skipNextNewLine = false;\n        this.lastChunkWritten = false;\n        this.endOfChunkHit = false;\n        this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;\n        this.isEol = false;\n        this.lineStartPos = 0;\n        this.droppedBufferSize = 0;\n        this.line = 1;\n        //NOTE: avoid reporting errors twice on advance/retreat\n        this.lastErrOffset = -1;\n    }\n    /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */\n    get col() {\n        return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);\n    }\n    get offset() {\n        return this.droppedBufferSize + this.pos;\n    }\n    getError(code) {\n        const { line, col, offset } = this;\n        return {\n            code,\n            startLine: line,\n            endLine: line,\n            startCol: col,\n            endCol: col,\n            startOffset: offset,\n            endOffset: offset,\n        };\n    }\n    _err(code) {\n        if (this.handler.onParseError && this.lastErrOffset !== this.offset) {\n            this.lastErrOffset = this.offset;\n            this.handler.onParseError(this.getError(code));\n        }\n    }\n    _addGap() {\n        this.gapStack.push(this.lastGapPos);\n        this.lastGapPos = this.pos;\n    }\n    _processSurrogate(cp) {\n        //NOTE: try to peek a surrogate pair\n        if (this.pos !== this.html.length - 1) {\n            const nextCp = this.html.charCodeAt(this.pos + 1);\n            if ((0, unicode_js_1.isSurrogatePair)(nextCp)) {\n                //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.\n                this.pos++;\n                //NOTE: add a gap that should be avoided during retreat\n                this._addGap();\n                return (0, unicode_js_1.getSurrogatePairCodePoint)(cp, nextCp);\n            }\n        }\n        //NOTE: we are at the end of a chunk, therefore we can't infer the surrogate pair yet.\n        else if (!this.lastChunkWritten) {\n            this.endOfChunkHit = true;\n            return unicode_js_1.CODE_POINTS.EOF;\n        }\n        //NOTE: isolated surrogate\n        this._err(error_codes_js_1.ERR.surrogateInInputStream);\n        return cp;\n    }\n    willDropParsedChunk() {\n        return this.pos > this.bufferWaterline;\n    }\n    dropParsedChunk() {\n        if (this.willDropParsedChunk()) {\n            this.html = this.html.substring(this.pos);\n            this.lineStartPos -= this.pos;\n            this.droppedBufferSize += this.pos;\n            this.pos = 0;\n            this.lastGapPos = -2;\n            this.gapStack.length = 0;\n        }\n    }\n    write(chunk, isLastChunk) {\n        if (this.html.length > 0) {\n            this.html += chunk;\n        }\n        else {\n            this.html = chunk;\n        }\n        this.endOfChunkHit = false;\n        this.lastChunkWritten = isLastChunk;\n    }\n    insertHtmlAtCurrentPos(chunk) {\n        this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);\n        this.endOfChunkHit = false;\n    }\n    startsWith(pattern, caseSensitive) {\n        // Check if our buffer has enough characters\n        if (this.pos + pattern.length > this.html.length) {\n            this.endOfChunkHit = !this.lastChunkWritten;\n            return false;\n        }\n        if (caseSensitive) {\n            return this.html.startsWith(pattern, this.pos);\n        }\n        for (let i = 0; i < pattern.length; i++) {\n            const cp = this.html.charCodeAt(this.pos + i) | 0x20;\n            if (cp !== pattern.charCodeAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    peek(offset) {\n        const pos = this.pos + offset;\n        if (pos >= this.html.length) {\n            this.endOfChunkHit = !this.lastChunkWritten;\n            return unicode_js_1.CODE_POINTS.EOF;\n        }\n        const code = this.html.charCodeAt(pos);\n        return code === unicode_js_1.CODE_POINTS.CARRIAGE_RETURN ? unicode_js_1.CODE_POINTS.LINE_FEED : code;\n    }\n    advance() {\n        this.pos++;\n        //NOTE: LF should be in the last column of the line\n        if (this.isEol) {\n            this.isEol = false;\n            this.line++;\n            this.lineStartPos = this.pos;\n        }\n        if (this.pos >= this.html.length) {\n            this.endOfChunkHit = !this.lastChunkWritten;\n            return unicode_js_1.CODE_POINTS.EOF;\n        }\n        let cp = this.html.charCodeAt(this.pos);\n        //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters\n        if (cp === unicode_js_1.CODE_POINTS.CARRIAGE_RETURN) {\n            this.isEol = true;\n            this.skipNextNewLine = true;\n            return unicode_js_1.CODE_POINTS.LINE_FEED;\n        }\n        //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character\n        //must be ignored.\n        if (cp === unicode_js_1.CODE_POINTS.LINE_FEED) {\n            this.isEol = true;\n            if (this.skipNextNewLine) {\n                // `line` will be bumped again in the recursive call.\n                this.line--;\n                this.skipNextNewLine = false;\n                this._addGap();\n                return this.advance();\n            }\n        }\n        this.skipNextNewLine = false;\n        if ((0, unicode_js_1.isSurrogate)(cp)) {\n            cp = this._processSurrogate(cp);\n        }\n        //OPTIMIZATION: first check if code point is in the common allowed\n        //range (ASCII alphanumeric, whitespaces, big chunk of BMP)\n        //before going into detailed performance cost validation.\n        const isCommonValidRange = this.handler.onParseError === null ||\n            (cp > 0x1f && cp < 0x7f) ||\n            cp === unicode_js_1.CODE_POINTS.LINE_FEED ||\n            cp === unicode_js_1.CODE_POINTS.CARRIAGE_RETURN ||\n            (cp > 0x9f && cp < 64976);\n        if (!isCommonValidRange) {\n            this._checkForProblematicCharacters(cp);\n        }\n        return cp;\n    }\n    _checkForProblematicCharacters(cp) {\n        if ((0, unicode_js_1.isControlCodePoint)(cp)) {\n            this._err(error_codes_js_1.ERR.controlCharacterInInputStream);\n        }\n        else if ((0, unicode_js_1.isUndefinedCodePoint)(cp)) {\n            this._err(error_codes_js_1.ERR.noncharacterInInputStream);\n        }\n    }\n    retreat(count) {\n        this.pos -= count;\n        while (this.pos < this.lastGapPos) {\n            this.lastGapPos = this.gapStack.pop();\n            this.pos--;\n        }\n        this.isEol = false;\n    }\n}\nexports.Preprocessor = Preprocessor;\n//# sourceMappingURL=preprocessor.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}